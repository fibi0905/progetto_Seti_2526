#include "client.h"

// Gestione risposte TCP generiche
void handle_tcp_response(Client *client, const char *response) {
    if (strncmp(response, "FRIE>", 5) == 0) {
        printf("Richiesta di amicizia inviata\n");
    } else if (strncmp(response, "FRIE<", 5) == 0) {
        printf("Cliente sconosciuto\n");
    } else if (strncmp(response, "MESS>", 5) == 0) {
        printf("Messaggio inviato\n");
    } else if (strncmp(response, "MESS<", 5) == 0) {
        printf("Impossibile inviare il messaggio (non amici o cliente inesistente)\n");
    } else if (strncmp(response, "FLOO>", 5) == 0) {
        printf("Messaggio di flood inviato\n");
    } else {
        printf("Risposta: %s\n", response);
    }
}

// Gestione risposte CONSU
void handle_consu_response(Client *client, const char *response) {
    if (strncmp(response, "NOCON", 5) == 0) {
        printf("Nessun flusso da consultare\n");
        return;
    }
    
    // SSEM>: Messaggio da un amico
    if (strncmp(response, "SSEM>", 5) == 0) {
        char sender_id[ID_LEN + 1];
        strncpy(sender_id, response + 6, ID_LEN);
        sender_id[ID_LEN] = '\0';
        
        const char *message = response + 6 + ID_LEN + 1; // +1 per lo spazio
        char mess[MAX_MESS_LEN + 1];
        int mess_len = strlen(message) - 3; // -3 per +++
        strncpy(mess, message, mess_len);
        mess[mess_len] = '\0';
        
        printf("\n>>> MESSAGGIO da %s: %s\n\n", sender_id, mess);
        return;
    }
    
    // OOLF>: Messaggio di flood
    if (strncmp(response, "OOLF>", 5) == 0) {
        char sender_id[ID_LEN + 1];
        strncpy(sender_id, response + 6, ID_LEN);
        sender_id[ID_LEN] = '\0';
        
        const char *message = response + 6 + ID_LEN + 1;
        char mess[MAX_MESS_LEN + 1];
        int mess_len = strlen(message) - 3;
        strncpy(mess, message, mess_len);
        mess[mess_len] = '\0';
        
        printf("\n>>> FLOOD da %s: %s\n\n", sender_id, mess);
        return;
    }
    
    // EIRF>: Richiesta di amicizia
    if (strncmp(response, "EIRF>", 5) == 0) {
        char sender_id[ID_LEN + 1];
        strncpy(sender_id, response + 6, ID_LEN);
        sender_id[ID_LEN] = '\0';
        
        printf("\n>>> RICHIESTA DI AMICIZIA da %s\n", sender_id);
        printf("Accettare? (s/n): ");
        
        char choice;
        scanf(" %c", &choice);
        getchar(); // Consuma newline
        
        char reply[BUFFER_SIZE];
        if (choice == 's' || choice == 'S') {
            snprintf(reply, BUFFER_SIZE, "OKIRF+++");
            printf("Richiesta accettata\n");
        } else {
            snprintf(reply, BUFFER_SIZE, "NOKRF+++");
            printf("Richiesta rifiutata\n");
        }
        
        send_tcp_message(client->tcp_socket, reply);
        
        char ack[BUFFER_SIZE];
        if (receive_tcp_message(client->tcp_socket, ack, BUFFER_SIZE) > 0) {
            if (strncmp(ack, "ACKRF", 5) == 0) {
                printf("Risposta confermata dal server\n\n");
            }
        }
        return;
    }
    
    // FRIEN: Accettazione amicizia
    if (strncmp(response, "FRIEN", 5) == 0) {
        char friend_id[ID_LEN + 1];
        strncpy(friend_id, response + 6, ID_LEN);
        friend_id[ID_LEN] = '\0';
        
        printf("\n>>> %s ha ACCETTATO la tua richiesta di amicizia!\n\n", friend_id);
        return;
    }
    
    // NOFRI: Rifiuto amicizia
    if (strncmp(response, "NOFRI", 5) == 0) {
        char friend_id[ID_LEN + 1];
        strncpy(friend_id, response + 6, ID_LEN);
        friend_id[ID_LEN] = '\0';
        
        printf("\n>>> %s ha RIFIUTATO la tua richiesta di amicizia\n\n", friend_id);
        return;
    }
    
    printf("Risposta sconosciuta: %s\n", response);
}

// Thread per ascoltare notifiche UDP
void *udp_listener_thread(void *arg) {
    Client *client = (Client *)arg;
    char buffer[4];
    struct sockaddr_in sender_addr;
    socklen_t addr_len = sizeof(sender_addr);
    
    printf("Thread UDP avviato, in ascolto sulla porta %u\n", client->udp_port);
    
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int n = recvfrom(client->udp_socket, buffer, 3, 0, 
                         (struct sockaddr *)&sender_addr, &addr_len);
        
        if (n == 3) {
            char notif_type = buffer[0];
            int num_flows = decode_hex_little_endian(buffer + 1);
            
            printf("\n*** NOTIFICA UDP ricevuta: [%c%c%c] ***\n", 
                   buffer[0], buffer[1], buffer[2]);
            printf("*** Tipo: %c, Flussi non consultati: %d ***\n", 
                   notif_type, num_flows);
            
            switch (notif_type) {
                case '0':
                    printf("*** Nuova RICHIESTA DI AMICIZIA ricevuta ***\n");
                    break;
                case '1':
                    printf("*** Richiesta di amicizia ACCETTATA ***\n");
                    break;
                case '2':
                    printf("*** Richiesta di amicizia RIFIUTATA ***\n");
                    break;
                case '3':
                    printf("*** Nuovo MESSAGGIO ricevuto ***\n");
                    break;
                case '4':
                    printf("*** Nuovo messaggio di FLOOD ricevuto ***\n");
                    break;
                default:
                    printf("*** Tipo di notifica sconosciuto ***\n");
            }
            printf("*** Usa CONSU per consultare i flussi ***\n\n");
        }
    }
    
    return NULL;
}